Varda server
============

A database for genomic variants.

**This is a work in progress, not ready for use!**


Description
-----------

Varda is an application for storing genomic variation data obtained from next-
generation sequencing experiments, such as full-genome or exome sequencing of
individuals or populations. Variants can be imported from standard formats
such as [VCF](http://www.1000genomes.org/wiki/Analysis/Variant%20Call%20Format/vcf-variant-call-format-version-41)
files, or annotated for presence in previously imported datasets.

Varda is implemented by very loosely coupled components, communicating using
a RESTful protocol over HTTP with json-encoded response payloads.

* *Varda server:* Exposes a RESTful API for managing and querying the variant
    database.
* *Varda client:* Command line client for querying the server
    non-interactively.
* *Varda web:* Web interface for browsing the server interactively.

This is Varda server.


Varda server
------------

The server is implemented in Python using the [Flask](http://flask.pocoo.org/)
framework and directly interfaces the PostgreSQL (or MySQL) database backend
using [SQLAlchemy](http://www.sqlalchemy.org/). It exposes a [RESTful](http://en.wikipedia.org/wiki/Representational_state_transfer)
API over HTTP where response payloads are (currently only) json-encoded. A
future version may use other encodings, depending on the value of the
Accept-Encoding header sent by the client.

Long-running actions are executed asynchonously through the [Celery](http://celeryproject.org/)
distributed task queue.


Installation
------------

Recommended is to work from a Python virtual environment, using [virtualenv](http://www.virtualenv.org/)
and [virtualenvwrapper](http://www.doughellmann.com/docs/virtualenvwrapper/).
The following notes include installation of these tools and assume a Debian
(testing, or *wheezy*) operating system with Python 2.7.

Install [pip](http://www.pip-installer.org/en/latest/index.html), virtualenv,
and virtualenvwrapper:

    $ sudo easy_install pip
    $ sudo pip install virtualenv
    $ sudo pip install virtualenvwrapper
    $ mkdir ~/.virtualenvs
    $ cat >> ~/.bashrc
    export WORKON_HOME=~/.virtualenvs
    source /usr/local/bin/virtualenvwrapper.sh
    export PIP_VIRTUALENV_BASE=$WORKON_HOME
    export PIP_REQUIRE_VIRTUALENV=true
    export PIP_RESPECT_VIRTUALENV=true
    ^D

Create an environment for Varda server:

    $ mkvirtualenv --no-site-packages varda-server

On of our dependencies is the psycopg2 Python package, for which we need some
PostgreSQL development libraries installed:

    $ sudo aptitude install python-dev libpq-dev

Alternatively, if we use [MySQL](http://www.mysql.com/) as our storage backend
through the MySQL-python package, we need some MySQL development libraries:

    $ sudo aptitutde install python-dev libmysqlclient-dev

We can now install all required Python packages (substitute MySQL-python for
psycopg2 in the requirements file if you choose MySQL):

    $ pip install -r requirements.txt

Next step is to setup our database server. For PostgreSQL:

    $ sudo aptitude install postgresql
    $ sudo -u postgres createuser --superuser $USER
    $ createuser --pwprompt --encrypted --no-adduser --no-createdb --no-createrole varda
    $ createdb --encoding=UNICODE --owner=varda varda
    $ createdb --encoding=UNICODE --owner=varda vardaresults

For MySQL:

    $ sudo aptitude install mysql-server
    $ mysql -h localhost -u root -p
    > create database varda;
    > create database vardaresults;
    > grant all privileges on varda.* to varda@localhost identified by 'varda';
    > grant all privileges on vardaresults.* to varda@localhost identified by 'varda';

The recommended message broker is [Redis](http://redis.io):

    $ sudo aptitude install redis-server

Alternatively, [RabbitMQ](http://www.rabbitmq.com/) can be used as message
broker (prefarably add the APT repository [provided by RabbitMQ](http://www.rabbitmq.com/install-debian.html)):

    $ sudo apt-get install postgresql rabbitmq-server
    $ sudo rabbitmqctl add_user varda varda
    $ sudo rabbitmqctl add_vhost varda
    $ sudo rabbitmqctl set_permissions -p varda varda '.*' '.*' '.*'

As a third alternative, but not recommended, you can use your database server
as message broker as well.


Configuration
-------------

Varda server looks for its configuration in the file specified by the
`VARDA_SETTINGS` environment variable. First create the file with your
configuration settings, for example:

    $ export VARDA_SETTINGS=~/varda-server/settings.py
    $ cat > $VARDA_SETTINGS
    ADMINS = ['martijn@vermaat.name']
    SQLALCHEMY_DATABASE_URI = 'postgresql://varda:varda@localhost/varda'
    CELERY_RESULT_BACKEND = 'database'
    CELERY_RESULT_DBURI = 'postgresql://varda:varda@localhost/vardaresults'
    BROKER_URL = 'redis://localhost:6379/0'

Some example settings can be found in `varda/default_settings.py`.


Database setup
--------------

The following is an example Python session creating the database tables and
setting up users. Make sure to have the `VARDA_SETTINGS` environment variable
set and our Python virtual environment active.

    from varda import create_app, db
    from varda.models import User

    app = create_app()
    app.test_request_context().push()

    db.drop_all()
    db.create_all()

    pietje = User('Pietje Puk', 'pietje', 'pi3tje', roles=['admin'])
    karel = User('Karel Koek', 'karel', 'k4rel', roles=['importer'])
    martijn = User('Martijn Vermaat', 'martijn', 'martijn',
                   roles=['admin', 'importer', 'annotator'])

    db.session.add(pietje)
    db.session.add(karel)
    db.session.add(martijn)
    db.session.commit()


Running Varda server
--------------------

Have your database server and message broker running and the `VARDA_SETTINGS`
environment variable set. Activate the Python virtual environment:

    $ workon varda-server

Start a Celery worker node (only used for long-running tasks):

    $ celery -A varda.worker.celery worker -l info

And start Varda server:

    $ ./runserver

You can now point your webbrowser to the URL that is printed and see a json-
encoded status page.


Unit tests
----------

Setup a database user and database for testing as described in `tests/test_api.py`
and then run the tests:

    $ nosetests -v


Documentation
-------------

Todo (surprise, surprise).


Copyright and license
---------------------

* Copyright (c) 2011-2012, Leiden University Medical Center <humgen@lumc.nl>
* Copyright (c) 2011-2012, Martijn Vermaat <martijn@vermaat.name>

Licensed under the [MIT license](http://en.wikipedia.org/wiki/MIT_License),
see the LICENSE file.
